# My Golden Rule of Software Quality

ソフトウェア開発で品質を高めるために自分が意識していること

## Prefer Upstream Fix
何らかの問題に直面したとき、手元でそれを直す前にそれが手元に閉じているのか、より上流の問題から派生しているのかを確認する. ソフトウェア開発で直面する手元の問題は、上流の問題の一端を見ているだけなケースがしばしばある.

ソフトウェアの品質(長期の保守性や変更容易性)を高めるには問題を下流ではなく上流で適切に修正する方が望ましい. また、問題をより低レイヤーで解消する方が望ましい.

より「上流」「低レイヤー」で問題を解決することで、その修正の恩恵を受ける対象のオーダーを増やすことができる.

場当たり的な修正でお茶を濁さず、どこまで上流まで遡って直せるか、
どこまで低レイヤーまで潜って問題を解決できるかがそのソフトウェアエンジニアの純粋な力量だと考えている.

結局のところ、よくある問題はフレームワークやアプリケーションのレイヤーよりも、ライブラリ、ミドルウェア、プラットフォームやインフラのレイヤーで根拠を持って解決できることが多い. フレームワークやアプリケーションのレイヤーでは、抽象化の殻を剥がすのに時間がかかるので、しばしば内部の挙動を予想して修正しないといけない.

勘が冴えて「賢い」方法を思いつくことがあるかもしれないが、プレゼンテーション(UI)層でのワークアラウンドやハックに頼るのは時間稼ぎにすぎないと意識しておきたい[^1].

この考えは [The golden rule of software quality](https://www.haskellforall.com/2020/07/the-golden-rule-of-software-quality.html) や某社での設計の問題から考えたことにインスパイアされている.

[^1]: プロダクトによっては「時間稼ぎ」が必要なフェーズも存在する. 問題はそのつけを誰がいつ払うか...


## You don't Need Micro Services (Yet)
マイクロサービスは極めて複雑なアーキテクチャなのでサービス群をオーケストレートする仕組みなしに秩序あるマイクロサービスを構成するのは難しい.

それぞれの機能をウェブアプリケーションとしてデプロイしサービス間で通信させるのは比較的容易にできるが、サービス間でデータの一貫性を保ったり、仕様変更(スキーマ・セマンティクスの両方を含む)をうまく伝播したりチーム間の責務を決めつつ分業したりしようと思ったら、その実現難易度は跳ね上がる.

マイクロサービスは実際に必要な場面[^2]もあったはずだが、それ以上にウェブアプリケーションしか作ったことがない開発者の「自分が慣れたやり方でやりたい」「他人の書いたコードベースを触りたくない」といった意図や、ミドルクラスの開発者の「トレンドの技術を追いたい」「分散システムを触りたい」といった欲求に応えてしまった印象がある.


我々が必要とするのは物理的に分散したウェブサービス群ではなく、責務の分離が機械的に保障されたコンポーネント群.
コンポーネントを別々のウェブサーバーとしてデプロイするまでもなく、言語機能、ビルドツールやライブラリで十分に実現できる[^3].

[^2]: 例えば、レガシーサービスを隠蔽するパターンやセキュリティ・パフォーマンス上の特異性があるケース
[^3]: 実現できるような言語、ツールチェーンやエコシステムを選ぶ必要はある


## Stick to Schema Driven Development for Within and Inter Team Communication 


健全なコードベースでもせいぜい5年もすれば腐る(初期の設計が現実の設計に合わなくなる、ライブラリ・フレームワークが死ぬ)ことを考えると、
スキーマ(IDL)の有無で置き換えの難易度がかなり変わるので、多少の工数をかけてでもスキーマファーストにしておくといい.

スキーマ(IDL)にはデータの構造の仕様(型)だけでなく、データのセマンティクスに関する仕様も記録しておくと置き換えがやりやすい. 構造として表現できないセマンティクス(例: 特定のルールに従う文字列)はドキュメントでもいいが、アノテーションなどの仕組みで機械判読可能な形で持っておくのが理想.

スキーマが以下の性質を満たしていると嬉しい.

- インターフェース(スキーマ)と実装(生成されたコード)の区別を強制する
- サービスの提供するデータの構造とデータのセマンティクスを機械判読可能な形式で集約させられる
- インターフェース(スキーマ)を壊すとその影響範囲が(静的解析などで)容易に判断できる

## Leave Side Effect(I/O) Until "The End of the World"

副作用(I/O) を伴うコードはテストがしにくい.
I/O 処理を可能な限り先延ばしにしてプログラムの終端で呼ぶようにモジュールを設計することでモジュールのテストのしやすさやコードベースの見通しの良さを改善できる.
