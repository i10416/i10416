# My Golden Rule of Software Quality

ソフトウェア開発で品質を高めるために自分が意識していること

## General
ソフトウェアの価値は「容易に変更できること」「変更容易性」にあるといっても過言ではない. ハードウェアは簡単に変更できないし、インフラもソフトウェアほど柔軟に変更できない.
変更容易性には「変更しやすさ」それ自体と「変更を入れる際の安心感」がある.

例えば、よく整理された一貫したアーキテクチャのソフトウェアに機能を追加するのは、散らかった場当たり的な設計のソフトウェアに機能を追加するよりも簡単である.
また、変更した際にその影響がより早い段階で特定できれば、その変更が既存のシステムを壊さないこと、あるいは壊すことを強い確信を持って判断できる.
静的解析や dry-run が変更の影響を開発プロセスの早い段階で検証してくれれば「どこが壊れるかわからないから手をつけられない」と変更を躊躇することもなくなる.

もう少し具体的な例を挙げると、インフラ構成それ自体の変更と比べて、terraform モジュールをより認知負荷が低い(凝縮度が高く、結合度が低い)構成にリファクタリングするのは簡単である.

## Prefer Upstream Fix
何らかの問題に直面したとき、手元でそれを直す前にそれが手元に閉じているのか、より上流の問題から派生しているのかを確認する. ソフトウェア開発で直面する手元の問題は、上流の問題の一端を見ているだけなケースがしばしばある[^0].

[^0]: もちろんソフトウェア開発に限った話ではない. チームメンバーのモチベーションの低下は、チームの問題かもしれないが、インセンティブ設計が壊れていたらチーム単位で"改善"してもジリ貧になる.

ソフトウェアの品質(長期の保守性や変更容易性)を高めるには問題を下流ではなく上流で適切に修正する方が望ましい. また、問題をより低レイヤーで解消する方が望ましい.

より「上流」「低レイヤー」で問題を解決することで、その修正の恩恵を受ける対象のオーダーを増やすことができる.

場当たり的な修正でお茶を濁さず、どこまで上流まで遡って直せるか、
どこまで低レイヤーまで潜って問題を解決できるかがそのソフトウェアエンジニアの純粋な力量だと考えている.

結局のところ、よくある問題はフレームワークやアプリケーションのレイヤーよりも、ライブラリ、ミドルウェア、プラットフォームやインフラのレイヤーで根拠を持って解決できることが多い. フレームワークやアプリケーションのレイヤーでは、抽象化の殻を剥がすのに時間がかかるので、しばしば内部の挙動を予想して修正しないといけない.

勘が冴えて「賢い」方法を思いつくことがあるかもしれないが、プレゼンテーション(UI)層でのワークアラウンドやハックに頼るのは時間稼ぎにすぎないと意識しておきたい[^1].

この考えは [The golden rule of software quality](https://www.haskellforall.com/2020/07/the-golden-rule-of-software-quality.html)、[技術力のボトムライン、技術的負債](https://izumisy.work/entry/2023/12/03/190229) や某社での設計の問題から考えたことに影響を受けている.

[^1]: プロダクトによっては「時間稼ぎ」が必要なフェーズも存在する. 問題はそのつけを誰がいつ払うか...


## You don't Need Micro Services (Yet)
マイクロサービスは極めて複雑なアーキテクチャなのでサービス群をオーケストレートする仕組みなしに秩序あるマイクロサービスを構成するのは難しい.

それぞれの機能をウェブアプリケーションとしてデプロイしサービス間で通信させるのは比較的容易にできるが、サービス間でデータの一貫性を保ったり、仕様変更(スキーマ・セマンティクスの両方を含む)をうまく伝播したりチーム間の責務を決めつつ分業したりしようと思ったら、その実現難易度は跳ね上がる.

マイクロサービスは実際に必要な場面[^2]もあったはずだが、それ以上にウェブアプリケーションしか作ったことがない開発者の「自分が慣れたやり方でやりたい」「他人の書いたコードベースを触りたくない」といった意図や、ミドルクラスの開発者の「トレンドの技術を追いたい」「分散システムを触りたい」といった欲求に応えてしまった印象がある.


我々が必要とするのは物理的に分散したウェブサービス群ではなく、責務の分離が機械的に保障されたコンポーネント群.
コンポーネントを別々のウェブサーバーとしてデプロイするまでもなく、言語機能、ビルドツールやライブラリで十分に実現できる[^3].

[^2]: 例えば、レガシーサービスを隠蔽するパターンやセキュリティ・パフォーマンス上の特異性があるケース
[^3]: 実現できるような言語、ツールチェーンやエコシステムを選ぶ必要はある


## Stick to Schema Driven Development for Within and Inter Team Communication 

健全なコードベースでもせいぜい5年もすれば腐る(初期の設計が現実の設計に合わなくなる、ライブラリ・フレームワークが死ぬ)ことを考えると、
スキーマ(IDL)の有無で置き換えの難易度がかなり変わるので、多少の工数をかけてでもスキーマファーストにしておくといい.

スキーマ(IDL)にはデータの構造の仕様(型)だけでなく、データのセマンティクスに関する仕様も記録しておくと置き換えがやりやすい. 構造として表現できないセマンティクス(例: 特定のルールに従う文字列)はドキュメントでもいいが、アノテーションなどの仕組みで機械判読可能な形で持っておくのが理想.

スキーマが以下の性質を満たしていると嬉しい.

- インターフェース(スキーマ)と実装(生成されたコード)の区別を強制する
- サービスの提供するデータの構造とデータのセマンティクスを機械判読可能な形式で集約させられる
- インターフェース(スキーマ)を壊すとその影響範囲が(静的解析などで)容易に判断できる

## Leave Side Effect(I/O) Until "The End of the World"

副作用(I/O) を伴うコードはテストがしにくい.
I/O 処理を可能な限り先延ばしにしてプログラムの終端で呼ぶようにモジュールを設計することでモジュールのテストのしやすさやコードベースの見通しの良さを改善できる.
