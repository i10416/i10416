DRAFT

## Prefer upstream fix

問題を下流ではなく上流で適切に修正する. 問題をより低レイヤーで解消する. 場当たり的な修正でお茶を濁さず、どこまで上流まで遡って直せるか、
どこまで低レイヤーまで潜って問題を解決できるかがそのソフトウェアエンジニアの純粋な力量だと思う.

よくある問題はよくある問題だからこそフレームワークやアプリケーションのレイヤーよりも、ライブラリ、ミドルウェア、プラットフォームやインフラのレイヤーで、ちゃんとした根拠を持って解決できることが多い.

## You don't need micro services

マイクロサービスは実際に必要な場面もあったはずだが、それ以上にウェブアプリケーションしか作ったことがない開発者の「自分が慣れたやり方でやりたい」
「他人の書いたコードベースを触りたくない」といった欲求や、ミドルクラスの開発者の「トレンドの技術を追いたい」「分散システムを触りたい」
といった欲求に応えてしまった印象がある.

我々が必要とするのは物理的に分散したウェブサービス群ではなく、論理的な責務の分離が機械的に保障されたコンポーネント群.
コンポーネントを別々のウェブサーバーとしてデプロイするまでもなく、言語機能、ビルドツールやライブラリで十分に実現できる[^1].

[^1]: 実現できるような言語、ツールチェーンやエコシステムを選ぶ必要はある

マイクロサービスの運用の技術的・組織的なオーバーヘッドは小さくない. コンポーネントそれぞれは単一のウェブサーバー内にあってもいいし、
異なるウェブサーバーにそれぞれ配置されていてもいいのだから、モジュラモノリスからはじめて必要に応じて別のサーバーに切り出していくのが吉.

次のケースではマイクロサービスを検討してもいいが、マイクロサービス以外の方法で実現できないか最大限検討するべき.

- トラフィックの特性が極めて異なる
- セキュリティや可用性などの非機能要件が異なる

## Stick to schema driven development for within and inter team communication 

- インターフェース(スキーマ)と実装(生成されたコード)の区別を強制する
- サービスの提供するデータの構造とデータのセマンティクスを機械判読可能な形式で集約させられる

## Type First &  Don't Validate, Parse! & Let compiler work for you

型に構造とセマンティクスをエンコードし、コンパイラの支援によってプログラムの正しさを一定保証する.

型や可視性修飾子によって不正なデータや状態が表現できないよう、また不正な操作が呼び出せないよう制約をつける.

また、型によって仕様が変わればそれがコンパイラに静的に検知される状態を作る.
「正しい仕様」がない場合でも頻繁に「仕様」を変えても全体が壊れないこと、セマンティクスがおかしくならないことを保証しなければならない.
Stringly Typed なモデリングやエラーの黙殺は問題を先送りにしているに過ぎない.

## Leave side-effects(I/O) until "the end of the world"

副作用(I/O) を伴うコードはテストがしにくい.
I/O 処理を可能な限り先延ばしにしてプログラムの終端で呼ぶようにモジュールを設計することでモジュールのテストのしやすさやコードベースの見通しの良さを改善できる.
