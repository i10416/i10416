# ソフトウェア開発の複雑性に関する覚え書き

最近はソフトウェア開発でいかにして複雑性を抑え込むか、複雑性をばら撒かないかに意識が向いている.

時間が経てば正解も自分のものごとの見方も変わるのであくまで執筆時点の話だが、
この文書では自分の経験則や知識をもとに複雑性の原因、その対処法, 考え方や To Be についてまとめる.

## マイクロサービス
### Problem
マイクロサービスは分散モノリス化したり、不要な車輪の再開発が発生したりして辛い.
[マイクロにしすぎた結果がこれだよ](https://www.slideshare.net/slideshow/ss-64839846/64839846) が自分の中で印象的.
分散システムの複雑性を抑え込む自信がないまま安易に手を出してはいけない.

### Solution

マイクロサービスを本格的にやるなら以下のような仕組みが欲しい.

- サービス間の契約
    - 実装詳細の抽象化・隠蔽
    - Well-Defined な仕様
- 横断的な関心ごとの分離
    - サービス間の認証・認可プロトコル
    - サービス内・サービス間のロギング・トレーシング
- サービス間で変更(追加・更新・廃止)を伝播する仕組み
- 自動生成


「モジュラモノリスが至高」とまでは言わないが、API ファーストな機能の連携、責務の分離や変更の独立したリリースは
ライブラリ設計、ビルドツールやフィーチャーフラグで解決できることも多い.

もちろんパフォーマンスやセキュリティの要求があるならサービスを物理的に別のところに配置する必要があるが、
設計でコントローラ層(HTTP Server や CLI)がうまく分離されていて入れ替えられるなら後から分割するのも難しくないはず.

位置透過的に実行可能な [Unison](https://www.unison-lang.org/) という新しい言語があるが early stage すぎて利用を憚られる.

## クラウド ピタゴラスイッチ
### Problem
クラウドの機能をふんだんに使うと短期的な工数は減るがピタゴラスイッチのようなアーキテクチャのせいで見通しが悪くなりデバッグやテストで時間が溶ける.

例えば AWS なら Kinesis, SQS, SNS, DynamoDB や Lambda, GCP なら Pub/Sub, 
Cloud Datastore や Cloud Functions を使うとイベントドリブンで無限にスケールするアーキテクチャを
比較的少ない実装で作れるが、こういったクラウドの機能をふんだんに使った構成では、
アプリケーションレイヤーはクラウドインフラ間を繋ぐグルーコードの役割を担うので
注意深く設計しないとアプリケーションレイヤーとインフラレイヤーが密結合になって辛い.

インフラを前提としたアプリケーションレイヤーは「意味のある」 テストを実装する負担がアプリケーションの実装の数倍重くなる.
ローカルファイルシステムやモックを使った動作確認はある程度バグを早期に発見することを助けてくれるが、
テストしたいことは十分にテストできないことが多くテストは通ってもデプロイするには不安が残る.

### Solution

銀の弾丸ではないが、以下の方針に従うとある程度は複雑性を抑えられる.

- I/O 処理とデータの変換処理を分離する. 目的はデータの変換処理部分をテストを容易にすること.
- 強い静的型付け言語を使う. 目的はスキーマやデータの整合性を実行時ではなくコンパイル時に検査すること.
- コード生成を利用してデータのシリアライズ・デシリアライズの境界で考えることを減らす.

また、S3 互換ストレージの [minio](https://min.io/) や [Lambda Runtime Interface Emulator(rie)](https://github.com/aws/aws-lambda-runtime-interface-emulator)
などを利用するとローカルでの動作確認が楽になる.
[LocalStack](https://www.localstack.cloud/) のような全部入りのツールを利用してもいいが、個人的には minio や rie のような最小限の要素を組み合わせる方が
不要な抽象化のレイヤーが減って扱いやすいと考えている.

## 認証
### Problem
ローカル環境と実行環境で認証の方式が異なっていると「ローカルならばこの設定を」「実行環境にはこの設定を」と考えることが増える.

### Solution
AWS の [Default Credentials Provider Chain](https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/credentials-chain.html) や
GCP の [Application Default Credentials](https://google.aip.dev/auth/4110) のようなプロトコルに乗っかることで、
実行環境ごとの認証の仕方を隠蔽してくれるのでコードに変更を加える必要が無くなって嬉しい. これらのプロトコルはなるべくシークレットを
開発者が設定しなくていいように設計されているのでセキュリティ面でもメリットがある.
例えば、 Cloud Run 上では APPLICATION_DEFAULT_CREDENTIALS などの環境変数を設定しなくてもサービスアカウントの権限をよしなに使ってくれる.


## データベース
データベースはネットワーク的に分離されたセキュアな環境におきたいが、一方で開発時やトラブル対応時になるべくスムーズにデータベースにアクセスできるようにしたい.

これを実現するツールは以下のような性質を見たしていてほしい.
- オープンで汎用的に使える
- 煩雑な手順が不要で宣言的に利用できる
- 既存の権限管理の仕組みを再利用できる

AWS ならば SSM, GCP ならば cloud-sql-proxy が近いが完全にユースケースを満たすかというと微妙なところ.

## データベースマイグレーション

???

## Blob の管理

### Problem

設定ファイル、画像・動画・3Dアセットなどのメディアコンテンツ、形態素解析の辞書や機械学習のモデルなどの Blob を配信したり、バージョン管理したりする(運用面・コスト面で)スマートな方法がわからない.

### Solution
ネットワークを跨いだデータの送受信自体は CDN + Blob Store(S3, GCS など)、認可が必要なら署名付き URL を利用すれば実現できる.

配信の典型的なパターンは URL に一定のルール(`z/x/y/name.ext`)を定める方法. わかりやすいものだと Map Box の地図のタイル画像で利用されている.

URL にルールを定めるなら Map Box のドキュメンテーション( https://docs.mapbox.com/ios/maps/api/6.4.1/tile-url-templates.html) のように仕様を明確にしておくといい.

機械学習モデルは実行時の初期化やバージョン管理・実験管理を意識する必要がある.
実行時の初期化は Cloud Run + GCS のマウントの構成をとれば比較的シンプルに実現できる.
ファイルの配置・読み込みは規約で管理できるのが理想.

機械学習のバージョン管理・実験管理のソリューションは Mlflow や wandb などが候補に上がるが完成度が物足りない.

3D アセットの管理では、アセットの制作者が必ずしもソフトウェアエンジニアの知識を持つわけではないため考えることが増える.
こちらも同じくファイルの配置・読み込みは規約で管理できるのが理想.

AWS には [Visual Asset Management System](https://github.com/awslabs/visual-asset-management-system) というソリューションがあるが、
これがどれくらい使えるのかはわかっていない.

## アプリケーションの状態管理

### Problem
アプリケーション内部の状態、例えば UI、並行処理における排他制御、Cache、初期化や JVM の暖気は状態が絡んでくるせいで複雑になりがち.

### Solution

#### 典型的な UI のパターン

#### 並行処理における排他制御のパターン

#### キャッシュのパターン

#### JVM の暖気


 
